<!DOCTYPE html>
<html>
<head>
<style>
	#info {
		position: absolute;
		top: 0px;
		width: 100%;
		padding: 10px;
		text-align: center;
		color: #ffff00
	}
	#gui {
		position: absolute;
		top: 0px;
		left: 0px;
		border: solid 1px green;
		//height: 350px;
	}
	body {
		overflow: hidden;
	}
</style>
</head>
<body>
<div id="info">測試<br>
<button id="makeCurve" style="width:20%">Make Curve</button>
<button id="build" style="width:20%">Build Road</button>
<button id="fly" style="width:20%">Fly</button>
<button id="clean" style="width:20%">Clean</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script>
var scene, renderer, camera;
var controls, plane;
var mousePoint;
var mouse = new THREE.Vector2();
var dataPoints = [];
var dataPointGroup = new THREE.Object3D();
var gcontrols;
var heightController;
var resController;
var type = "centripetal",type1,type2,type3;
var raycaster;
var pickables = [];

init();
animate();

$("#makeCurve").click(function() {
	console.log('in makeCurve');
	makeCatmullRom();
});
$("#build").click(function() {
	console.log('building');
	building(0);
});
$("#fly").click(function() {
	console.log('flying');
	flying(0);
});
$("#clean").click(function() {
	console.log('clean');
	cleanRestart();
});

function findMax(v){
	if(v.x > v.y)return v.x > v.z ? v.x : v.z;
	else return v.y > v.z ? v.y : v.z;
}

function unitize (object, targetSize) {
	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	
	// uniform scaling according to objSize
	var objSize = findMax(size); 
	var scaleSet = targetSize/objSize;
	var theObject =  new THREE.Object3D();
	theObject.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);

	return theObject;
}

function buildplane(){
	var onProgress = function(xhr){
		if(xhr.lengthComputable){
			var percenComplete = xhr.loaded / xhr.total * 100;
		}
	}
	var onError = function(xhr){};
	plane = new THREE.Object3D();
	var mtlLoader = new THREE.MTLLoader();
	mtlLoader.setPath('resources/test1/');
	mtlLoader.load('starscreamjet-mode.mtl', function(materials) {
		materials.preload();
		var objLoader = new THREE.OBJLoader();
		objLoader.setMaterials(materials);
		objLoader.setPath('resources/test1/');
		objLoader.load('starscreamjet-mode.obj', function(object) {

			var obj =  unitize (object, 10);
			plane.add(obj);
			obj.rotation.set(0, Math.PI, 0);
			plane.traverse (
				function (mesh) {
					if (mesh instanceof THREE.Mesh) {
						mesh.castShadow = true;
						mesh.receiveShadow = true;
					}
				}
			);
			scene.add (plane);
		}, onProgress, onError);
	});
}

function init() {
	scene = new THREE.Scene();
	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);

	camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
	camera.position.z = 200;
	controls = new THREE.OrbitControls(camera, renderer.domElement);

	var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
	scene.add(gridXZ);

	light = new THREE.AmbientLight(0xffffff);
	scene.add(light);
	buildplane();
	scene.add(dataPointGroup);
	
	gcontrols = {
		height: 0,
		resolution: 20,
		closed: false,
		centripetal: function(){type = "centripetal";},
		chordal: function(){type = "chordal";},
		catmullrom: function(){type = "catmullrom";}
	};

	var gui = new dat.GUI();
	gui.domElement.id = 'gui';

	heightController = gui.add(gcontrols, 'height', 0, 50);
	resController = gui.add(gcontrols, 'resolution', 10, 50);
	closedController = gui.add(gcontrols, 'closed');
	type1 = gui.add(gcontrols, 'centripetal').name('centripetal');
	type2 = gui.add(gcontrols, 'chordal').name('chordal');
	type3 = gui.add(gcontrols, 'catmullrom').name('catmullrom');
	//typeController = gui.add(gcontrols, 'type', ["centripetal", "chordal", "catmullrom"]);
	
	planex = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial({
		transparent: true,
		opacity: 0.5,
		visible: true
	}));
	scene.add(planex);
	planex.rotation.x = -Math.PI / 2;
	pickables = [planex];
	raycaster = new THREE.Raycaster();
	
	window.addEventListener('resize', onWindowResize, false);
	document.addEventListener('mousedown', onDocumentMouseDown, false);
}

function makeCatmullRom() {
	var cat;
	// if line exists, remove it...
	if (cat = scene.getObjectByName('catmull')) {
		scene.remove(cat);
		cat.children[0].geometry.dispose();
		cat.children[1].geometry.dispose();
	}

	var curve = new THREE.CatmullRomCurve3(dataPoints);
	curve.type = type;
	curve.closed = gcontrols.closed;

	var geometry = new THREE.Geometry();
	geometry.vertices = //curve.getPoints(Math.floor(gcontrols.resolution));      // no !
	curve.getSpacedPoints(Math.floor(gcontrols.resolution)); // yes!

	var material = new THREE.LineBasicMaterial({
		color: 0xffff00
	});

	var lineAndPt = new THREE.Object3D();
	var line = new THREE.Line(geometry, material);
	lineAndPt.add(line);
	lineAndPt.name = "catmull";

	var dataPointMesh = new THREE.Points(line.geometry.clone());
	dataPointMesh.material.size = 5;
	dataPointMesh.material.color = new THREE.Color('white');
	lineAndPt.add(dataPointMesh);

	scene.add(lineAndPt);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function makeADot(pos) {
	var geometry = new THREE.CircleGeometry(3, 32);
	var material = new THREE.MeshBasicMaterial({
		color: 0xffff00
	});
	var circle = new THREE.Mesh(geometry, material);
	circle.rotation.x=-Math.PI/2;
	circle.position.copy(pos);
	return circle;
}

function cleanRestart() {
	var cat;
	if (cat = scene.getObjectByName('catmull')) {
		scene.remove(cat);
		cat.children[0].geometry.dispose();
		dataPoints = [];
		dataPointGroup.children = [];
	}
}

function onDocumentMouseDown(event) {
	event.preventDefault();
	mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	raycaster.setFromCamera(mouse, camera);
	var intersects = raycaster.intersectObjects(pickables);

	//if (event.button === 2)
	if (intersects.length > 0)	{ // right button
		cleanRestart();
		var pos = new THREE.Vector3(intersects[0].point.x, gcontrols.height, intersects[0].point.z);
		dataPoints.push(pos);
		var pt = makeADot(pos);
		dataPointGroup.add(pt);
	}
}

function Matrix4Update(newPos, newDir) {
	var localX = newDir.clone().normalize();
	var localY = new THREE.Vector3(0,0,1);
	localY.sub(localY.clone().projectOnVector(localX)).normalize();
	var localZ = new THREE.Vector3();
	localZ.crossVectors (localX, localY);
	plane.matrix.makeBasis (localX, localY, localZ);
	plane.matrix.setPosition (newPos);
	plane.matrixAutoUpdate = false;
}

function myMatrix4Update(mesh, newPos, newDir) {
	var localX = newDir.clone().normalize();
	var localY = new THREE.Vector3(0,1,0);
	localY.sub(localY.clone().projectOnVector(localX)).normalize();
	var localZ = new THREE.Vector3();
	localZ.crossVectors (localX, localY);
	mesh.matrix.makeBasis (localX, localY, localZ);
	mesh.matrix.setPosition (newPos);
	mesh.matrixAutoUpdate = false;
	dataPointGroup.add(mesh);
}

function building(i){
	var j = Math.floor(gcontrols.resolution);
	var curve = new THREE.CatmullRomCurve3(dataPoints);
	curve.type = type;
	curve.closed = gcontrols.closed;
	
	if(i<=j){
		var mesh = new THREE.Mesh(new THREE.BoxGeometry( 5, 2, 15), new THREE.MultiMaterial(
			[
			new THREE.MeshLambertMaterial({ // +x
			  color: 0x00ffff
			}),
			new THREE.MeshLambertMaterial({ // -x
			  color: 0xffff00
			}),
			new THREE.MeshLambertMaterial({ // +y
			  color: 0xff00ff
			}),
			new THREE.MeshLambertMaterial({ // -Y
			  color: 0x00ff00
			}),
			new THREE.MeshLambertMaterial({ // +z
			  color: 0xffff00
			}),
			new THREE.MeshLambertMaterial({ // -Z
			  color: 0x0000ff
			})
		]));
		//mesh.position.copy(curve.getPointAt(i/j));
		myMatrix4Update(mesh,curve.getPointAt(i/j),curve.getTangentAt(i/j));
		setTimeout(function(){building(i+1)},10);
	}
}

function flying(i){
	var j = Math.floor(gcontrols.resolution)*10;
	var curve = new THREE.CatmullRomCurve3(dataPoints);
	curve.type = type;
	curve.closed = gcontrols.closed;
	
	if(i<j){
		Matrix4Update(curve.getPointAt(i/j),curve.getTangentAt(i/j));
		setTimeout(function(){flying(i+1)},10);
	}
}

function animate() {
	controls.update();
	
	heightController.onFinishChange(function() {
		console.log(gcontrols.height);
	});
	closedController.onChange(function() {
		console.log(gcontrols.closed);
		makeCatmullRom();
	});
	resController.onFinishChange(function() {
		console.log(gcontrols.resolution);
		makeCatmullRom();
	});
	/*typeController.onFinishChange(function() {
		console.log(gcontrols.type);
		makeCatmullRom();
	});*/
	requestAnimationFrame(animate);
	renderer.render(scene, camera);
}
</script>
</body>

</html>